package parser

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"golang.org/x/tools/imports"
)

const (
	echoPkg     = "echo"
	echoPkgPath = "x.io/xrpc/pkg/echo"
)

func HttpStub(meta *MetaData, b StubBuilder, w io.Writer) error {
	wb := bytes.NewBuffer([]byte(nil))
	gen := &Generator{w: bytes.NewBuffer([]byte{})}
	b.Gen(meta, gen)
	stubPkgs := meta.StubPkgs()
	if EnableHeader {
		wb.Write([]byte(fmt.Sprintf(`// Code generated by echo. DO NOT EDIT.
// source: %s.go`, meta.name)))
		wb.Write([]byte("\n\n"))
	}

	wb.Write([]byte(fmt.Sprintf("package %s\n\n", meta.Name())))
	wb.Write([]byte("import (\n"))
	for _, p := range stubPkgs {
		wb.Write([]byte("    "))
		wb.Write([]byte(p.String() + "\n"))
	}
	wb.Write([]byte(")\n\n"))
	wb.Write([]byte(gen.String()))

	src := wb.Bytes()
	// goimports stub file
	{
		out, err := imports.Process("", src, nil)
		if err != nil {
			fmt.Fprint(os.Stderr, src)
			fmt.Fprintln(os.Stderr, "imports.Process:", err) // Output is like "gen.go:8:18: expected ...".
			os.Exit(1)
		}
		src = out
	}
	_, err := w.Write(src)
	return err
}

func NewHttpStubBuilder() StubBuilder {
	return &httpStubBuilder{}
}

type httpStubBuilder struct {
}

func (b *httpStubBuilder) Gen(meta *MetaData, x *Generator) error {
	for _, service := range meta.Interfaces() {
		servName := service.Name
		serviceDescVar := "_" + servName + "ServiceDesc"
		fullServName := fmt.Sprintf("%s.%s", meta.Name(), service.Name)
		// Server registration.
		x.P("func Register", servName, "Server(prefix string, e *echo.Echo, srv ", servName, ") error {")
		// Service descriptor.
		x.P("var ", serviceDescVar, " = ", echoPkg, ".ServiceDesc {")
		x.P("ServiceName: ", strconv.Quote(fullServName), ",")
		x.P("HandlerType: (", servName, ")(nil),")
		x.P("Methods: []", echoPkg, ".MethodDesc{")
		for _, method := range service.AllMethods() {
			x.P("{")
			x.P("MethodName: ", strconv.Quote(method.Name), ",")
			comment := method.Doc
			if len(method.Comment) > 0 {
				comment = method.Comment
			}
			index := strings.Index(comment, " ")
			if index <= 0 {
				continue
			}
			httpMethod := comment[:index]
			path := comment[index+1:]
			path = strings.Replace(path, "\n", "", -1)
			x.P("HttpMethod: echo.", httpMethod, ",")
			x.P("Path: ", strconv.Quote(path), ",")
			x.F("Handler: srv.(%s).%s,", servName, method.Name)
			x.P("},")
		}
		x.P("},")
		x.P("Metadata: \"", meta.Name(), "\",")
		x.P("}")
		x.P("if len(prefix) > 0 {")
		x.P("var m *echo.MethodDesc")
		x.F("for i := range %s.Methods {", serviceDescVar)
		x.F("m = &%s.Methods[i]", serviceDescVar)
		x.P("m.Path = prefix + m.Path")
		x.P("}")
		x.P("}")
		x.P("return e.RegisterService(&", serviceDescVar, `, srv)`)
		x.P("}")
		x.P()
	}
	return nil
}

// Code generated by xrpc. DO NOT EDIT.
// source: math.go

package math

import (
    "context"
    "fmt"
    "github.com/edenzhong7/xrpc"
    "github.com/edenzhong7/xrpc/pkg/codes"
)

// CounterClient is the client API for Counter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/github.com/edenzhong7/xrpc#ClientConn.NewStream.
type CounterClient interface {
    Inc(n1,n2 *Num) (n3 Num)
    Dec(n1,n2 Num) *Num
}

type counterClient struct {
    cc *xrpc.ClientConn
}

func NewCounterClient(cc *xrpc.ClientConn) CounterClient {
    return &counterClient{cc}
}

func (c *counterClient) Inc(n1,n2 *Num) (n3 Num) {
    panic("unimplemented client method: Inc")
}

func (c *counterClient) Dec(n1,n2 Num) *Num {
    panic("unimplemented client method: Dec")
}

// MathClient is the client API for Math service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/github.com/edenzhong7/xrpc#ClientConn.NewStream.
type MathClient interface {
    Inc(n1,n2 *Num) (n3 Num)
    Dec(n1,n2 Num) *Num
    Add(ctx context.Context, a,b int, n Num) (int, *Num)
    Sub(a,b int, n *Num) (cc int, nn Num)
    Sum(a int, n *Num, ctxs []context.Context, ns []int, is []interface{}, nns [][]int, nms []map[int]string, mns map[int][]string, ms map[string]interface{}, nm map[int]*Num, varargs ...interface{}) (x int, y map[int]map[string]interface{}, z map[int]*Num)
}

type mathClient struct {
    cc *xrpc.ClientConn
}

func NewMathClient(cc *xrpc.ClientConn) MathClient {
    return &mathClient{cc}
}

func (c *mathClient) Inc(n1,n2 *Num) (n3 Num) {
    panic("unimplemented client method: Inc")
}

func (c *mathClient) Dec(n1,n2 Num) *Num {
    panic("unimplemented client method: Dec")
}

func (c *mathClient) Add(ctx context.Context, a,b int, n Num) (int, *Num) {
    panic("unimplemented client method: Add")
}

func (c *mathClient) Sub(a,b int, n *Num) (cc int, nn Num) {
    panic("unimplemented client method: Sub")
}

func (c *mathClient) Sum(a int, n *Num, ctxs []context.Context, ns []int, is []interface{}, nns [][]int, nms []map[int]string, mns map[int][]string, ms map[string]interface{}, nm map[int]*Num, varargs ...interface{}) (x int, y map[int]map[string]interface{}, z map[int]*Num) {
    panic("unimplemented client method: Sum")
}

// UnimplementedCounter can be embedded to have forward compatible implementations.
type UnimplementedCounter struct {
}

func (*UnimplementedCounter) Inc(n1,n2 *Num) (n3 Num) {
    panic(fmt.Sprint(codes.Unimplemented, "method Inc not implemented"))
}

func (*UnimplementedCounter) Dec(n1,n2 Num) *Num {
    panic(fmt.Sprint(codes.Unimplemented, "method Dec not implemented"))
}

func RegisterCounterServer(s *xrpc.Server, srv Counter) {
    s.RegisterService(&_Counter_serviceDesc, srv)
}

func _Counter_Inc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor xrpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(*Num)
    if err := dec(in); err != nil { return nil, err }
    if interceptor == nil { _ = srv.(Counter).Inc }
    info := &xrpc.UnaryServerInfo{
        Server: srv,
        FullMethod: "/math.Counter/Inc",
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        _ = srv.(Counter).Inc
        panic("gg")
    }
    return interceptor(ctx, in, info, handler)
}

func _Counter_Dec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor xrpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(Num)
    if err := dec(in); err != nil { return nil, err }
    if interceptor == nil { _ = srv.(Counter).Dec }
    info := &xrpc.UnaryServerInfo{
        Server: srv,
        FullMethod: "/math.Counter/Dec",
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        _ = srv.(Counter).Dec
        panic("gg")
    }
    return interceptor(ctx, in, info, handler)
}

var _Counter_serviceDesc = xrpc.ServiceDesc {
    ServiceName: "math.Counter",
    HandlerType: (*Counter)(nil),
    Methods: []xrpc.MethodDesc{
        {
            MethodName: "Inc",
            Handler: _Counter_Inc_Handler,
        },
        {
            MethodName: "Dec",
            Handler: _Counter_Dec_Handler,
        },
    },
    Streams: []xrpc.StreamDesc{},
    Metadata: "math",
}

// UnimplementedMath can be embedded to have forward compatible implementations.
type UnimplementedMath struct {
}

func (*UnimplementedMath) Inc(n1,n2 *Num) (n3 Num) {
    panic(fmt.Sprint(codes.Unimplemented, "method Inc not implemented"))
}

func (*UnimplementedMath) Dec(n1,n2 Num) *Num {
    panic(fmt.Sprint(codes.Unimplemented, "method Dec not implemented"))
}

func (*UnimplementedMath) Add(ctx context.Context, a,b int, n Num) (int, *Num) {
    panic(fmt.Sprint(codes.Unimplemented, "method Add not implemented"))
}

func (*UnimplementedMath) Sub(a,b int, n *Num) (cc int, nn Num) {
    panic(fmt.Sprint(codes.Unimplemented, "method Sub not implemented"))
}

func (*UnimplementedMath) Sum(a int, n *Num, ctxs []context.Context, ns []int, is []interface{}, nns [][]int, nms []map[int]string, mns map[int][]string, ms map[string]interface{}, nm map[int]*Num, varargs ...interface{}) (x int, y map[int]map[string]interface{}, z map[int]*Num) {
    panic(fmt.Sprint(codes.Unimplemented, "method Sum not implemented"))
}

func RegisterMathServer(s *xrpc.Server, srv Math) {
    s.RegisterService(&_Math_serviceDesc, srv)
}

func _Math_Inc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor xrpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(*Num)
    if err := dec(in); err != nil { return nil, err }
    if interceptor == nil { _ = srv.(Math).Inc }
    info := &xrpc.UnaryServerInfo{
        Server: srv,
        FullMethod: "/math.Math/Inc",
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        _ = srv.(Math).Inc
        panic("gg")
    }
    return interceptor(ctx, in, info, handler)
}

func _Math_Dec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor xrpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(Num)
    if err := dec(in); err != nil { return nil, err }
    if interceptor == nil { _ = srv.(Math).Dec }
    info := &xrpc.UnaryServerInfo{
        Server: srv,
        FullMethod: "/math.Math/Dec",
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        _ = srv.(Math).Dec
        panic("gg")
    }
    return interceptor(ctx, in, info, handler)
}

func _Math_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor xrpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(context.Context)
    if err := dec(in); err != nil { return nil, err }
    if interceptor == nil { _ = srv.(Math).Add }
    info := &xrpc.UnaryServerInfo{
        Server: srv,
        FullMethod: "/math.Math/Add",
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        _ = srv.(Math).Add
        panic("gg")
    }
    return interceptor(ctx, in, info, handler)
}

func _Math_Sub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor xrpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(int)
    if err := dec(in); err != nil { return nil, err }
    if interceptor == nil { _ = srv.(Math).Sub }
    info := &xrpc.UnaryServerInfo{
        Server: srv,
        FullMethod: "/math.Math/Sub",
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        _ = srv.(Math).Sub
        panic("gg")
    }
    return interceptor(ctx, in, info, handler)
}

func _Math_Sum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor xrpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(int)
    if err := dec(in); err != nil { return nil, err }
    if interceptor == nil { _ = srv.(Math).Sum }
    info := &xrpc.UnaryServerInfo{
        Server: srv,
        FullMethod: "/math.Math/Sum",
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        _ = srv.(Math).Sum
        panic("gg")
    }
    return interceptor(ctx, in, info, handler)
}

var _Math_serviceDesc = xrpc.ServiceDesc {
    ServiceName: "math.Math",
    HandlerType: (*Math)(nil),
    Methods: []xrpc.MethodDesc{
        {
            MethodName: "Inc",
            Handler: _Math_Inc_Handler,
        },
        {
            MethodName: "Dec",
            Handler: _Math_Dec_Handler,
        },
        {
            MethodName: "Add",
            Handler: _Math_Add_Handler,
        },
        {
            MethodName: "Sub",
            Handler: _Math_Sub_Handler,
        },
        {
            MethodName: "Sum",
            Handler: _Math_Sum_Handler,
        },
    },
    Streams: []xrpc.StreamDesc{},
    Metadata: "math",
}

